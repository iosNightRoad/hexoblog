title: "ios手势密码四川兄原创"
tag: [ios]
categories: ios
---


﻿```
 #import <UIKit/UIKit.h> #import <QuartzCore/QuartzCore.h> @interface GesturePassword : UIView @property(nonatomic,strong)NSMutableArray *recordMovePoints; @property(nonatomic,assign)void(^generatePassword)(GesturePassword *, NSString *); @property(nonatomic,strong)UIWindow *currentWindow; @property(nonatomic,strong)NSString *rightPwd; -(void)registNotifyHandle; -(void)hideSelf; -(void)showSelf; -(GesturePassword *)initByFrame; @end 
#import \"GesturePassword.h\" //记录触碰点 static NSMutableArray *recordCricleViews = nil; //是否允许绘图，因为起点必须先点击到圆圈上 static BOOL canDraw = NO; //基础tag，用来记录圆圈的tag，这个也用来组成密码 const static int PointBaseTag = 1; //线宽 const static int LineWidth = 6; #define BetweenWithNumber(V,A,B) [[NSPredicate predicateWithFormat:@\"self between {%f,%f}\",[(A) floatValue],[(B) floatValue]] evaluateWithObject:(V)] @implementation GesturePassword @synthesize recordMovePoints,generatePassword,currentWindow,rightPwd; //注册通知， -(void)registNotifyHandle{ //    后台来的时候执行锁屏操作     [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(showLockScreen) name:UIApplicationWillEnterForegroundNotification object:nil]; } -(void)showLockScreen{     static BOOL hadAddSubview = NO; //    如果是挂上了，就直封屏     if(hadAddSubview){         [self showSelf];         return;     } //    挂在window上。     UIWindow *statusWindow = [[[UIApplication sharedApplication] delegate] window];     statusWindow.windowLevel = UIWindowLevelStatusBar;     [statusWindow addSubview:self];     hadAddSubview = YES; }  //初始化。 -(GesturePassword *)initByFrame{     if((self = [self initWithFrame:[[UIScreen mainScreen] bounds]])){     }     return self; } //初始化frame。 - (id)initWithFrame:(CGRect)frame {     self = [super initWithFrame:frame];     recordMovePoints = [NSMutableArray array];     if (self) {         recordCricleViews = [NSMutableArray array];         UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(gestPanGesture:)];         panGesture.minimumNumberOfTouches = panGesture.maximumNumberOfTouches = 1;         [self addGestureRecognizer:panGesture];         int i = 0,row=-1;         float w = self.frame.size.width, h = self.frame.size.height, radius = 20 , diameter = radius * 2;         //            算出每个物体之间的左右间距、         float spearX  = (w - (diameter * 3)) / 4,spearY = (h - (diameter * 3)) / 4;         while (i<9) {             int step = i%3;             if(step==0)++row;             float tempX = (step + 1) * spearX + step * diameter,tempY = (row+1) * spearY + row * diameter;             @autoreleasepool {                 CGRect tempRect = CGRectMake(tempX, tempY, diameter, diameter);                 UIView *cricleView = [[UIView alloc] initWithFrame:tempRect];                 cricleView.tag = PointBaseTag + i ;                 cricleView.layer.cornerRadius = radius;                 cricleView.backgroundColor = [UIColor grayColor];                 [self addSubview:cricleView];                 [recordCricleViews addObject:cricleView];             }             ++i;         }     }     return self; } //是否和几个目标物发生碰撞 -(UIView *)hasTouchCricleView:(CGPoint)point{     __block UIView *resultView = nil;     [recordCricleViews  enumerateObjectsUsingBlock:^(UIView *sview,NSUInteger index,BOOL *stop){         if([self rectsTouched:point eimRect:sview.frame]){             resultView = sview;             *stop = YES;         }     }];     return resultView; } //检测当前点击坐标和物体是否碰撞 -(BOOL)rectsTouched:(CGPoint )pointA eimRect:(CGRect)rectB{     BOOL inX = BetweenWithNumber(@(pointA.x),@(rectB.origin.x),@(rectB.origin.x + rectB.size.width)),                 inY = BetweenWithNumber(@(pointA.y),@(rectB.origin.y),@(rectB.origin.y + rectB.size.height));     return inX && inY; } //拖动手势 -(void)gestPanGesture:(UIPanGestureRecognizer *)pan{ //    松开     if(pan.state == UIGestureRecognizerStateEnded){         [recordCricleViews enumerateObjectsUsingBlock:^(UIView *tview,NSUInteger index,BOOL *stop){             [tview setBackgroundColor:[UIColor grayColor]];         }];         NSMutableString *string = [NSMutableString string];         [recordMovePoints enumerateObjectsUsingBlock:^(NSArray *array,NSUInteger index,BOOL *stop){ //            过滤掉0             if([array[0] intValue]>0)             [string appendFormat:@\"%d\",[array[0] intValue]];         }];         recordMovePoints = nil;         canDraw = NO;         [self setNeedsDisplay];         if(generatePassword){             generatePassword(self,string);         }         return;     } //    按下     else if(pan.state == UIGestureRecognizerStateBegan){         CGPoint touchPoint  = [pan locationInView:pan.view];         UIView *tempTouchedView = [self hasTouchCricleView:touchPoint];         if(tempTouchedView){             recordMovePoints = [NSMutableArray arrayWithObject:@[@(tempTouchedView.tag),[NSValue valueWithCGPoint:tempTouchedView.center]]];             tempTouchedView.backgroundColor = [UIColor greenColor];             canDraw = YES;         }else{             canDraw = NO;         }     } //    move。     else if(pan.state == UIGestureRecognizerStateChanged){         if(!canDraw)return; //    判断拖动边界。         CGPoint touchPoint  = [pan locationInView:pan.view];         float dx = touchPoint.x,         dy = touchPoint.y; //        越界不能。         if(!BetweenWithNumber(@(dx),@0,@(self.frame.size.width)) || !BetweenWithNumber(@(dy),@0,@(self.frame.size.height)))return;         UIView *tempTouchedView = [self hasTouchCricleView:touchPoint]; //        不能重复。                  if(tempTouchedView){             if([[recordMovePoints filteredArrayUsingPredicate:[NSPredicate predicateWithFormat:@\"self[0] ==%d\",tempTouchedView.tag]] count]==0){                 if([[recordMovePoints lastObject][0] intValue]==0)[recordMovePoints removeObject:[recordMovePoints lastObject]]; //                NSLog(@\"recordMovePoints:%@\",recordMovePoints);                 tempTouchedView.backgroundColor = [UIColor greenColor];                 [recordMovePoints addObject:@[@(tempTouchedView.tag),[NSValue valueWithCGPoint:tempTouchedView.center]]];                 [self setNeedsDisplay];             }         }else{             if([[recordMovePoints lastObject][0] intValue]==0)[recordMovePoints removeObject:[recordMovePoints lastObject]];             [recordMovePoints addObject:@[@0,[NSValue valueWithCGPoint:touchPoint]]];             [self setNeedsDisplay];         }     } } -(void)hideSelf{     CGRect rect = self.frame;     rect.origin.y = [[UIScreen mainScreen] applicationFrame].size.height + 20;     [UIView animateWithDuration:1 animations:^{         [self setFrame:rect];     }]; } -(void)showSelf{     CGRect rect = self.frame;     rect.origin.y = 0;     [self setFrame:rect]; } //画图 -(void)drawRect:(CGRect)rect{     CGContextRef context = UIGraphicsGetCurrentContext();     UIGraphicsBeginImageContextWithOptions(self.frame.size, YES, 1); //    如果没有记录拖拽的点，就清空     if(recordMovePoints==nil || recordMovePoints.count<=1){         CGContextSetFillColorWithColor(context, self.backgroundColor.CGColor);         return CGContextFillPath(context);     } //    设置圆滑拐角     CGContextSetLineJoin(context, kCGLineJoinRound);     CGPoint beginPoint = [recordMovePoints[0][1] CGPointValue];     CGContextMoveToPoint(context, beginPoint.x, beginPoint.y);     CGContextSetLineWidth(context, LineWidth);     CGContextSetStrokeColorWithColor(context, [UIColor yellowColor].CGColor); //    开始画，根据点。     [recordMovePoints enumerateObjectsUsingBlock:^(NSArray *array,NSUInteger index,BOOL *stop){         CGPoint tempPoint = [array[1]  CGPointValue];         CGContextAddLineToPoint(context, tempPoint.x, tempPoint.y);     }];     CGContextStrokePath(context); } @end 调用： GesturePassword *pwdBoard = [[GesturePassword alloc] initByFrame];     pwdBoard.backgroundColor = [UIColor brownColor]; //    注册通知。     [pwdBoard registNotifyHandle];     pwdBoard.generatePassword = ^(GesturePassword *passboard,NSString *pwdString){         if([pwdString isEqualToString:@\"123456\"]){             [passboard hideSelf];         }     };
```


